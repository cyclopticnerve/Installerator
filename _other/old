
    # --------------------------------------------------------------------------
    # Helpers
    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    # Load dictionary data from a file
    # --------------------------------------------------------------------------
    # def __load_conf(self):

    #     # make sure the file exists
    #     if not os.path.exists(self.conf_path):
    #         print('Could not find config file')
    #         exit()

    #     # read config file
    #     with open(self.conf_path, 'r') as file:
    #         try:
    #             self.conf_dict = json.load(file)

    #             # make sure we have minimum keys
    #             self.__merge_conf_dicts(self.conf_dict_def, self.conf_dict)
    #         except Exception as error:
    #             print(f'could not load config file: {error}')
    #             exit()

    # # --------------------------------------------------------------------------
    # # Perform substitutions for paths in config file
    # # --------------------------------------------------------------------------
    # def __make_subs(self):

    #     # get current user's home dir
    #     home_dir = os.path.expanduser('~')

    #     # the dict of substitutions
    #     sub_dict = {
    #         '${HOME}': home_dir
    #     }

    #     # create a temporary dict (can't modify conf_dict while iterating)
    #     tmp_dict = self.conf_dict.copy()

    #     # for each section in the conf dict
    #     for sect_name, sect_dict in tmp_dict.items():

    #         # if it's a list
    #         if isinstance(sect_dict, list):

    #             # empty the target list
    #             self.conf_dict[sect_name] = []

    #             # for each item
    #             for item in sect_dict:

    #                 # assume unchanged
    #                 tmp_item = item

    #                 # if it's a string
    #                 if isinstance(item, str):

    #                     # do the substitution
    #                     for sub_key, sub_val in sub_dict.items():
    #                         tmp_item = tmp_item.replace(sub_key, sub_val)

    #                 # modify user list
    #                 self.conf_dict[sect_name].append(tmp_item)

    #         # if it's a dict
    #         elif isinstance(sect_dict, dict):

    #             # for each kv pair in dict
    #             for key, val in sect_dict.items():

    #                 # assume unchanged
    #                 tmp_val = val

    #                 # if the val is a string
    #                 if isinstance(val, str):

    #                     # do the substitution
    #                     for sub_key, sub_val in sub_dict.items():
    #                         tmp_val = tmp_val.replace(sub_key, sub_val)

    #                 # modify user dict
    #                 self.conf_dict[sect_name][key] = tmp_val

    # # --------------------------------------------------------------------------
    # # Check if we are going to need sudo password and get it now
    # # --------------------------------------------------------------------------
    # def __check_sudo(self):

    #     # if either of theses steps is required, we need sudo
    #     if self.__needs_step('sys_reqs') or self.__needs_step('py_reqs'):

    #         # ask for sudo password now
    #         cmd = 'sudo echo -n'
    #         cmd_array = shlex.split(cmd)
    #         subprocess.run(cmd_array)

    # # --------------------------------------------------------------------------
    # # Check if a step needs to be performed or can be skipped
    # # --------------------------------------------------------------------------
    # def __needs_step(self, step):

    #     # if the section is present
    #     if step in self.conf_dict.keys():
    #         conf_dict = self.conf_dict[step]

    #         # if there are entries in the section
    #         if len(conf_dict):
    #             return True

    #     # otherwise we can skip this step
    #     return False

    # # --------------------------------------------------------------------------
    # # Merge required keys from def dict to user dict
    # # --------------------------------------------------------------------------
    # def __merge_conf_dicts(self, dict_src, dict_dst, path=''):

    #     # if types match
    #     if type(dict_src) == type(dict_dst):

    #         # if both dicts
    #         if isinstance(dict_src, dict):
    #             for key in dict_src.keys():

    #                 # if key in src but not dest
    #                 if key not in dict_dst.keys():

    #                     # just copy the whole key/value
    #                     dict_dst[key] = dict_src[key]

    #                 # key is in both
    #                 else:

    #                     # recurse to next level for matching
    #                     path = path + '/' + key
    #                     self.__merge_conf_dicts(dict_src[key], dict_dst[key],
    #                                             path)

    #         # if both lists
    #         elif isinstance(dict_src, list):
    #             for item in dict_src:

    #                 # if item in src but not dst
    #                 if item not in dict_dst:

    #                     # add to dst
    #                     dict_dst.append(item)

    #     # dict/list mismatch
    #     else:
    #         raise Exception(f'Merge type mismatch: {path}')

# def __run(self, cmd=''):
#     try:
#         cp = subprocess.run(shlex.split(cmd), check=True)
#     except CalledProcessError as error:
#         pass

    # --------------------------------------------------------------------------
    # Perform substitutions for paths in config file
    # --------------------------------------------------------------------------
    # def dict_substitute(self):

        # if isinstance(dict_dst, dict):
        #     for key in dict_dst.keys():
        #         self._dict_substitute_by_index(self.sub_dict, dict_dst, key)
        #         # TODO: replace key names by adding new copy of dict
        #         # with new key name, then pop old dict

        # elif isinstance(dict_dst, list):
        #     for i in range(len(dict_dst)):
        #         self._dict_substitute_by_index(self.sub_dict, dict_dst, i)

    # --------------------------------------------------------------------------
    # Private function to do the substitution in leaf elements
    # --------------------------------------------------------------------------
    # def _dict_substitute_by_index(self, dict_subs, dict_dst, index):

    #     if isinstance(dict_dst[index], dict) or isinstance(dict_dst[index], list):
    #         self.dict_substitute(dict_dst[index])

    #     elif isinstance(dict_dst[index], str):
    #         new_str = dict_dst[index]
    #         for sub_key, sub_val in dict_subs.items():
    #             new_str = new_str.replace(sub_key, sub_val)
    #         dict_dst[index] = new_str
